# 树
## 定义和基本术语
+ 树是由一个集合以及在该集合上定义的一种关系构成。
+ 集合中的元素称为树的结点，所定义的关系称为父子关系
+ 父子关系在树的节点之间建立了一个层次结构
+ 在这种层次结构中有一个结点具有特殊的位置，这个结点称为该树的根结点，或简称为树根
+ 没有儿子结点的结点叫做子节点
+ 节点的层次 level 从根开始定义，层次数为 0 的结点是根节点，其子树的根的层次数为 1
+ 树中的节点的最大层次数称为树的深度 depth 或高度。树中节点也有高度，其高度是以该节点为根的树的高度
+ 节点拥有的子树的数目称为节点的度 degree
+ 度为 0 的节点称为叶子 leaf 节点。度不为 0 的节点称为非终端节点或分支节点。除根之外的分支节点也成为内部节点
+ 书中的节点数等于树的边数加 1，也等于所有节点的度数之和加 1 （性质）
+ 在树中节点总数与边的总数是相当的，基于这一事实，在对涉及树结构的算法复杂性进行分析时，可以用节点的数目作为规模的度量

路径
+ 在树中 k + 1 个节点通过 k 条边连接构成的序列{ (v0, v1), (v1, v2), ... ,(vk-1, vk) | k >= 0}，称为长度为 k 的路径（path）
+ 树中任意两个节点之间都存在唯一的路径。这意味着树既是连通的，同时又不会出现环路。从根节点开始，存在到其他任意节点的一条唯一路径，跟到某个节点路径的长度，恰好是该节点的层次数

有序树、m叉树、森林
+ 如果将树中的节点的各子树堪称是从左至右是有次序的，则称该树为有序树；若不考虑子树的顺序则称为无序树。对于有序树，我们可以明确的定义每个节点的第一个孩子、第二个孩子等，直到最后一个孩子。如不特别指明，一般讨论的树都是有序树
+ 树中所有节点的最大度数为 m 的有序树，称为 m 叉树
+ 森林 forest 是 m （m >= 0) 棵互不相交的树的集合。对树中每个节点而言，其子树的集合即为森林。树和森林的概念相近。删去一颗树的根，就得到一个森林；反之，加上一个节点做为树根，森林就变为一颗树。

## 树的核心——节点
### 结构
### 基本操作
+ 节点数
+ 获取根节点
+ 获取父节点
+ 获取第一个孩子节点
+ 获取兄弟节点
+ 获取节点的高度
+ 新增节点
+ 删除节点
+ 前序遍历
+ 后序遍历
+ 层次遍历

天才创造套路，庸人学习套路

技巧： 
+ 深搜用递归
+ 广搜用队列
  + 弹一个，加 n 个（不保留层次）
  + 增加标志位（队列中增加元素，或者设置标志指针）

### 二叉树
+ 每个节点的度不超过 2 的有序树，称为二叉树（binary tree）
+ 与树的递归定义类似，二叉树的递归定义如如下：二叉树或者是一棵空树，或者是一棵由一个根节点和两棵互不相交的分别称为根的左子树和右子树的子树所组成的非空树

#### 性质
+ 在二叉树的第 i 层上最多有 2^i 个节点(满二叉树)
+ 高度为 h 的二叉树最多有 2^(h + 1) - 1 个节点
+ 对于任何一棵二叉树 T，如果其终端节点数为 n0，度为 2 的节点数为 n2，则 n0 = n2 + 1
  + 总节点数 n = 度数 + 1 = 1 * n1 + 2 * n2 + 1
  + 总节点数 n = n1 + n0 + + n2 ---> n0 = n2 + 1
+ 有 n 个节点的完全二叉树的高度为 Math.floor(logn) // 向下取整
+ 还有 n >= 1个节点的二叉树的高度之多为 n - 1；高度至少为 Math.floor(logn)
+ 

#### 特殊的二叉树

+ 满二叉树
  + 高度为 k 并且有 2^(k + 1) 个节点的二叉树。在满二叉树中，**每层节点都达到最大数**，即每层节点都是满的，因此称为满二叉树
+ 完全二叉树
  + 若在一棵满二叉树中，在最下层从右侧起去掉相邻的若干叶子节点，得到的二叉树即为完全二叉树
  + 满二叉树是一种特殊的完全二叉树
  + 如果对一棵有 n 个节点的完全二叉树的节点进行编号，则对任一节点 i (1 <= i <= n)，有
    + 如果 i = 1 ，则节点 i 是二叉树的根，无双亲；如果 i > 1，则其双亲节点 parent(i) 是节点 Math.floor(2 / i)
    + 如果 2i > n，则节点 i 无左孩子；否则其左孩子是节点 2i
    + 如果 2i + 1 > n，则节点 i 无右孩子；否则其右孩子是节点 2i + 1

##### BST 二叉查找树（二叉搜索树）binary search tree
+ 或者是一棵空树，或者是具有以下性质的二叉树：
  + 若它的左子树不空，则其左子树中所有节点的值不大于根节点的值
  + 若它的右子树不空，则其右子树中所有节点的值不小于根节点的值
  + 它的左、右子树都是二叉查找树
+ 结论：中序遍历一棵二叉查找树可以得到一个按关键字递增的有序序列

操作：
+ 新增节点
+ 中序遍历
+ 查找元素
+ 获取最小关键字
+ 获取最大关键字

实现二叉查找树
