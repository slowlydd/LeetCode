# 线性结构
## 面向对象要点、数据结构要点

+ 对象将数据和操作打包在一起，类描述了一切
+ 用构造器创建对象
+ 类和类之间的关系
  + 关联（组合、聚合）
  + 泛化
+ 祖先类 Object
+ 方法重写
+ toString 方法
+ equals 方法
+ 接口概述 定义了一组功能，实现就是完成接口定义的一系列功能

数据：一切可以输入计算机并能被处理的都是数据
+ 数据项：不可再拆分
+ 数据元素 一条记录
+ 数据对象

### 数据结构
逻辑结构
+ 集合：元素罗列在一起
+ 线性结构：元素前后相继
+ 树形结构：元素存在一对多的关系
+ 图结构或网状结构：元素之间存在多对多关系

存储结构
+ 顺序存储：地址连续，用数组
+ 链式存储：地址不连续，用指针（引用，面向对象）

数据结构按照特别的方式存储是为了便于按特定方式取出来

数据结构的主要运算（操作）
+ 建立（Create）一个数据结构
+ 消除（Destory）一个数据结构
+ 从一个数据结构中删除（Delete）一个数据元素
+ 把一个数据元素插入（Insert）到一个数据结构中
+ 对一个数据结构进行访问（Access）
+ 对一个数据结构（中的数据元素）进行修改（Modify）（Update）
+ 对一个数据结构进行排序（Sort）
+ 对一个数据结构进行查找（Search）

为了某种特殊需求（操作）而专门设计的数据的存储方式（结构）
增删改查，排序，遍历

## 基于顺序存储和链式存储的列表
### 列表
+ 定义列表的接口
+ 用数组实现列表——MyArrayList
+ 实现链表
+ 迭代器
+ 泛型
+ Java List API
+ 相关技巧


#### todo
+ 利用数组实现一个线性表
+ 实现一个链表（单链表，双链表（哑元来统一操作））
+ 比较两个的操作复杂度

> 考虑边界与越界问题
> 再简单的代码还是需要去测试一下
> 哑元

例题：（主要考链表）
+ 桶排序  (ele * n)/(maxIndex + 1) (适用于分布均匀的) 
  + 所有都插入一个桶里就变成了插入排序
+ 移除重复节点
  + 编写代码，移除未排序链表中的重复节点 hash set（进阶：如果不得使用临时缓冲区，该怎么解决） （leetcode，面试题 02.01. 移除重复节点）
+ 实现一个算法，找出单向链表中倒数第 k 个结点（双指针，快慢指针，一个先行 k 次，然后两个一起，快的到了末位，慢的就是倒数第 k 位）
+ 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点，如果该结点是最后一个，则返回 false （复制后继的内容，越过后继）
+ 编写代码，以给定值 x 为基准将链表分割成两部分，所有小于 x 的结点排在大于或等于 x 的结点之前，给定一个链表的头指针，请返回重新排列后的链表的头指针
  + 注意：分割以后保持原来的数据顺序不变
  + 不要开辟新的空间，即不要新建节点
+ 有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对着两个整数求和，并用链表形式返回结果。
  + 进阶（如果都是正向存储的话，如何再做一遍）
+ 给定一个有环链表，实现一个算法返回环路的开头节点 （hash set 判断重复）
  + 进阶：不用 hash set 使用快慢指针
+ 检查链表是否回文
  + 反转链表（用递归反转链表）
  + 栈结构
### 栈
+ stack 又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除操作
+ 表中进行插入、删除操作的一端称为栈顶，栈顶保存的元素称为栈顶元素。相对的，表的另一端称为栈底元素
+ 当栈中没有数据元素时称为空栈；向一个栈插入元素又称为进栈或入栈；从一个栈中删除元素又称为出栈或退栈
+ 由于栈的插入和删除操作仅在栈顶进行，后进栈的元素必定先出栈，所以又把堆栈称为后进先出表（Last In First Out，简称LIFO）
+ peek 查看栈顶的元素，不弹出
实现一个栈
+ 用双向链表实现一个栈
### 队列
+ 队列（queue），它同堆栈一样，也是一种运算受限的线性表，器限制是仅允许在表的一端进行插入，而在表的另一端进行删除。在队列中把插入数据元素的一端称为队尾，删除数据的一端称为队首
+ 向队尾插入元素称为进队或入队，新元素入队后称为新的队尾元素；从队列中删除称为离队或出兑，元素出队后，其后续元素称为新的队首元素
+ 由于队列的插入和删除操作分别在队尾和队首进行，每个元素必然按照进入的次序离队，也就是说先进队的元素必然先离队，所以称队列为先进先出表（First In First Out，简称 FIFO）。队列结构与日常生活中排队等候服务的模型是一致的，最早进入队列的人，最早得到服务并从队首离开；最后到来的人只能排在队列的最后，最后得到服务并最后离开

面试题目：
+ 描述如何只用一个数组来实现三个栈
+ 请设计一个栈，除 pop 与 push 方法，还支持 min 方法，可返回栈元素的最小值。push、pop 和 min 三个方法的时间复杂度必须为 O(1)  
  + 用另一个栈来维护最小值（空间换时间）
  + 进阶 如果元素没有重复，可以判断来节约空间 栈顶一样，两个栈都弹栈，如果不一样，弹一个栈
+ 实现一种数据结构 SetOfStack，由多个栈组成，其中每个栈的大小为 size，当前一个栈顶满的时候，新建一个栈。该数据结构应支持与普通栈相同的 push 和 pop 操作。
+ 实现一个 MyQueue 类，该类用两个栈来实现一个队列 （进阶：为空的时候进行反转节约空间）
+ 编写一个程序，按照升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。
+ 有家动物收容所只收留猫和狗，但有特殊的收养规则，收养有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫和狗），并收养该种动物最早进入收容所的。
  + 给定一个操作序列 int[][2] 代表所有事件
  + 若第一个元素为 1 ，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫
  + 若第一个元素为 2，则代表有人收养动物，第二个元素若为 0，则采取第一种收养方式（最早）
  + 若为 1，则指定收养狗，若为 -1 则指定养猫。
  + 请按照顺序返回收养的序列。若出现不合法操作，即没有可以符合领养要求的动物，贼将这次领养操作忽略
    + 链表模拟队列
    + 两个队列 注意记录猫狗进入的时间
### 哈希（hash， 散列）工具类
#### hash map hash set

基本概念：
+ 若关键字为 k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可取得所查记录。称这个对应关系 f 为散列函数，按这个思想建立的表为散列表
+ 对不不同的关键字可能得到同一散列地址，即 k1 != k2，而 f(1) = f(2)，这种现象称为冲突（英语：Collision）。具有函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集上，并以关键字在地址集中的 “像” 作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得到的存储位置称散列地址。

桶排序就是一种特殊的哈希（桶排序很重要）

两个关键点：（目的是快速查找）
+ 散列函数
  + 直接地址法
  + 数字分析法
  + 平方取中法
  + 折叠法
  + 随机数法
  + **除留余数法**
+ 冲突解决
  + 开放定址法
  + **拉链法**
  + 双散列
  + 再散列

实现简版的 Hash Map

实现 hash set 用于存单个元素
set 就是一个集合

### 布隆过滤器
工业实践中用的比较多的一种算法，
主要用于判断一个元素是否存在于一个集合中（主要用于海量数据）加快查找

基本概念：
+ 布隆过滤器（Bloom Filter）是 1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难
+ 如果想判断一个元素是不是在一个集合里，一般想到的是将集合的所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为 O(n)、O(logN)、O(n/k)。布隆过滤器的原理是，当一个元素被加入集合时，通过 k 个散列函数将这个元素映射成一个位数组中的 k 个点，把他们置为 1 。检索时，我们只要看看这些点是不是都是 1 就知道（大约）集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。

### 一直性哈希

缓存集群/负载均衡

路由算法：
+ 余数哈希
  + 扩容
  + 故障
+ 一致性哈希算法
  + 基本思路
  + 先构造一个长度为 2^32 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 hash 值（其分布为[0, 2^32 - 1]）将缓存服务器节点放置在这个 Hash 环上，然后根据需要缓存的数据的 key 值计算得到其 hash 值（其分布也为 [0, 2^32 - 1]，然后再 Hash 环上顺时针查找距离这个 key 值的 Hash 值最近的服务器节点，完成 Key 到服务器的映射查找
  + 如果往集群中添加一个新的节点，通过对应的 hash 算法得到的 k，并映射到环中
  + 按顺时针迁移的规则，那么被分割的对象被迁移到了 node 中，其它对象还还保持着原有的存储位置（影响的数据范围比较小）
  + 数据倾斜
    + 如果机器较少，很有可能造成机器在这个环上的分布不均匀，从而导致机器之间的负载不均衡（用虚拟节点来解决）
  + 实现，不考虑数据倾斜
    + 1.哈希算法，将关键字映射到 2^32 的环状空间里面
    + 机器节点 === 网络节点
    + 初始节点
    + 增加了节点以后怎么办？需要进行数据迁移，逆时针找上一个节点 
    + 去掉节点以后？ 需要进行数据迁移

#### 哈希题解
+ 有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数
+ 32 位无符号整数的范围是 0 ~ 4294967295，现在有一个证号包含 40 亿个无符号整数的大文件，所以在整个范围中必然有没出现过的数。可以使用最多 1GB 的内存，怎么找到所有没出现过的数 
  + 分成多个小文件，依次处理小文件
  + 位图，布隆过滤器的方式
  + 知识点（空间的计算）
+ 找到 100 亿个URL中重复的 URL 以及搜索词汇的 topK 问题
